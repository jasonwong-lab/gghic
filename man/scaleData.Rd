% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gghic-methods.R
\name{scaleData}
\alias{scaleData}
\title{Scale Hi-C interaction data}
\usage{
scaleData(data, scale_column, scale_method, remove_na = FALSE)
}
\arguments{
\item{data}{A \code{ChromatinContacts}, \code{GInteractions}, \code{data.frame}, or \code{tibble}
object containing chromatin interaction data.}

\item{scale_column}{Character string. Name of the column to scale (e.g.,
\code{"balanced"}, \code{"count"}).}

\item{scale_method}{Function to apply for scaling. Common choices include
\code{log10}, \code{log2}, or identity function \code{function(x) x}.}

\item{remove_na}{Logical. If \code{TRUE}, removes rows with \code{NA} or infinite
values in the score column. Default is \code{FALSE}.}
}
\value{
A tibble with columns: \code{seqnames1}, \code{start1}, \code{end1}, \code{seqnames2},
\code{start2}, \code{end2}, and \code{score} (the scaled values).
}
\description{
Transforms and scales chromatin interaction data for visualization. Applies
a scaling function to a specified column and handles missing values.
}
\details{
The function:
\enumerate{
\item Converts input data to a tibble format
\item Applies the scaling method to the specified column
\item Creates a \code{score} column with the transformed values
\item Optionally removes missing values
\item Applies out-of-bounds squishing to ensure values are within range
}
}
\examples{
\dontrun{
# Load Hi-C data
cc <- ChromatinContacts("path/to/cooler.cool") |>
  import()

# Scale using log10 transformation (most common)
scaled_data <- scaleData(cc, "balanced", log10)
head(scaled_data)

# Use raw counts without transformation
scaled_raw <- scaleData(cc, "count", function(x) x)

# Scale with log2 and remove missing values
scaled_clean <- scaleData(cc, "balanced", log2, remove_na = TRUE)

# From GInteractions object
gis <- interactions(cc)
scaled_gis <- scaleData(gis, "balanced", log10)

# From data frame (must have required columns)
df <- as.data.frame(gis)
scaled_df <- scaleData(df, "count", log10)

# Percentile rank transformation
percentile_rank <- function(x) {
  rank(x, na.last = "keep") / sum(!is.na(x))
}
scaled_pct <- scaleData(cc, "balanced", percentile_rank)

# Use with ggplot2 directly
library(ggplot2)
ggplot(scaled_data, aes(x = (start1 + end1) / 2, y = score)) +
  geom_point(alpha = 0.1) +
  labs(title = "Distance decay", x = "Position", y = "Log10(balanced)")
}
}
