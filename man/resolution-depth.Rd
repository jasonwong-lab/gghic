% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/resolution-depth.R
\name{resolution-depth}
\alias{resolution-depth}
\alias{calculateResolutionDepth}
\alias{calculateGenomeCoverage}
\alias{findOptimalResolution}
\alias{readPairsCache}
\alias{calcResDepthChunked}
\alias{calcGenomeCovChunked}
\alias{findOptResChunked}
\title{Calculate Resolution and Depth for Pairs Data}
\usage{
calculateResolutionDepth(pairs, bin_size)

calculateGenomeCoverage(pairs, bin_size, min_contacts = 1000)

findOptimalResolution(
  pairs,
  min_bin = 1000,
  max_bin = 5e+06,
  target_coverage = 0.8,
  min_contacts = 1000
)

readPairsCache(pairs_file)

calcResDepthChunked(pairs_file = NULL, bin_size, cache = NULL)

calcGenomeCovChunked(
  pairs_file = NULL,
  bin_size,
  min_contacts = 1000,
  cache = NULL
)

findOptResChunked(
  pairs_file = NULL,
  min_bin = 1000,
  max_bin = 5e+06,
  target_coverage = 0.8,
  min_contacts = 1000,
  cache = NULL,
  return_cache = FALSE
)
}
\arguments{
\item{pairs}{Data frame with columns: \code{read_name}, \code{chrom1}, \code{pos1},
\code{chrom2}, \code{pos2}. For large files, use \code{pairs_file} instead.}

\item{bin_size}{Integer. Bin size in base pairs.}

\item{min_contacts}{Integer. Minimum contacts per bin (default: 1000).}

\item{min_bin}{Integer. Minimum bin size for search (default: 1000).}

\item{max_bin}{Integer. Maximum bin size for search (default: 5000000).}

\item{target_coverage}{Numeric (0-1). Target coverage fraction (default:
0.8).}

\item{pairs_file}{Character path to pairs file.}

\item{cache}{External pointer from \code{readPairsCache()}. Faster for repeated
operations.}

\item{return_cache}{Logical. Return list with bin size and cache pointer
(default: FALSE).}
}
\value{
\itemize{
\item \code{calculateResolutionDepth()}: Tibble with chrom, bin, count.
\item \code{calculateGenomeCoverage()}: Coverage fraction (bins â‰¥ min_contacts).
\item \code{findOptimalResolution()}: Optimal bin size (integer).
\item \code{calcResDepthChunked()}: Same, reads file in chunks.
\item \code{calcGenomeCovChunked()}: Coverage from file.
\item \code{findOptResChunked()}: Optimal resolution for large files.
}

An external pointer to the cached data.
}
\description{
Functions to analyze genomic interaction resolution and coverage depth.

Load a pairs file into C memory for fast repeated analysis.
The cache persists until garbage collected or explicitly cleared.
}
\details{
Analyzes Hi-C pairs to determine optimal resolution. For large files, use
\verb{_chunked} variants or cache with \code{readPairsCache()} for speed.
}
\examples{
\dontrun{
pairs <- read.table("contact_matrix.txt")
depth_10kb <- calculateResolutionDepth(pairs, bin_size = 10000)
coverage <- calculateGenomeCoverage(pairs, bin_size = 10000)
opt_bin <- findOptimalResolution(pairs, target_coverage = 0.8)

# Large file with cache
cache <- readPairsCache("contact_matrix.txt")
opt_bin <- findOptResChunked(cache = cache, target_coverage = 0.8)
depth <- calcResDepthChunked(cache = cache, bin_size = opt_bin)
}

\dontrun{
# Create cache once
cache <- readPairsCache("data.pairs.gz")

# Reuse cache for multiple operations
depth1 <- calcResDepthChunked(cache = cache, bin_size = 10000)
depth2 <- calcResDepthChunked(cache = cache, bin_size = 50000)
coverage <- calcGenomeCovChunked(cache = cache, bin_size = 10000)

# Cache is automatically freed when R session ends
# Or explicitly remove it:
rm(cache)
gc()
}

}
